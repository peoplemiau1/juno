#!/usr/bin/env ruby
# Unified Juno CLI

require 'optparse'
require 'fileutils'
require_relative "src/lexer"
require_relative "src/parser"
require_relative "src/importer"
require_relative "src/monomorphizer"
require_relative "src/optimizer/turbo"
require_relative "src/codegen/native_generator"
require_relative "src/preprocessor"
require_relative "src/errors"

LOGO = <<-'EOF'
      ____.
     |    |__ __  ____   ____
     |    |  |  \/    \ /  _ \
 /\__|    |  |  /   |  (  <_> )
 \________|____/|___|  /\____/
                     \/
    Juno Compiler v1.2 - "Hell Edition"
EOF

options = {
  arch: :x86_64,
  os: :linux,
  output: nil,
  hell: false,
  hell_level: :hell,
  run: false
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: juno [options] <input_file>"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-a", "--arch ARCH", [:x86_64, :aarch64], "Target architecture (x86_64, aarch64)") do |a|
    options[:arch] = a
  end

  opts.on("-o", "--output FILE", "Output binary path") do |o|
    options[:output] = o
  end

  opts.on("-t", "--target OS", [:linux, :windows, :flat], "Target OS (linux, windows, flat)") do |t|
    options[:os] = t
  end

  opts.on("--hell [LEVEL]", [:easy, :medium, :hard, :nightmare, :hell], "Enable HELL MODE obfuscation") do |level|
    options[:hell] = true
    options[:hell_level] = level || :hell
  end

  opts.on("-r", "--run", "Run after compilation") do
    options[:run] = true
  end

  opts.on("-v", "--version", "Show version") do
    puts LOGO
    exit
  end

  opts.on("-h", "--help", "Prints this help") do
    puts LOGO
    puts opts
    exit
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption, OptionParser::MissingArgument => e
  puts "\e[31mError:\e[0m #{e.message}"
  puts "Use --help for usage information."
  exit 1
end

if ARGV.empty?
  puts LOGO
  puts parser
  exit
end

if ARGV[0] == "help"
  puts LOGO
  puts parser
  exit
elsif ARGV[0] == "version"
  puts LOGO
  exit
end

input_file = ARGV[0]
unless File.exist?(input_file)
  puts "\e[31mError:\e[0m File not found: #{input_file}"
  exit 1
end

output_path = options[:output] || case options[:os]
  when :linux then "build/output_#{options[:arch]}"
  when :windows then "build/output.exe"
  when :flat then "build/output.bin"
end

$hell_mode = nil
if options[:hell]
  require_relative "src/polymorph/hell_mode"
  $hell_mode = HellMode.new(options[:hell_level], options[:arch])
  puts "HELL MODE ACTIVATED - Level: #{options[:hell_level]} for #{options[:arch]}"
end

begin
  code = File.read(input_file)

  preprocessor = Preprocessor.new
  preprocessor.define(options[:os].to_s.upcase)
  preprocessor.define("__JUNO__")
  preprocessor.define("__#{options[:arch]}__")
  code = preprocessor.process(code, input_file)

  lexer = Lexer.new(code, input_file)
  tokens = lexer.tokenize

  parser = Parser.new(tokens, input_file, code)
  ast = parser.parse

  importer = Importer.new(File.dirname(input_file))
  ast = importer.resolve(ast, input_file)

  monomorphizer = Monomorphizer.new(ast)
  ast = monomorphizer.monomorphize

  optimizer = TurboOptimizer.new(ast)
  ast = optimizer.optimize

  generator = NativeGenerator.new(ast, options[:os], options[:arch])
  generator.hell_mode = $hell_mode if $hell_mode
  FileUtils.mkdir_p("build")
  generator.generate(output_path)

  puts "Success! Binary generated: #{output_path}"
  $hell_mode.report if $hell_mode

  if options[:run]
    if options[:os] == :linux
      puts "Executing..."
      exec("./#{output_path}")
    else
      puts "Running not supported for this target yet."
    end
  end
rescue JunoError => e
  e.display
  exit 1
rescue => e
  puts "\e[31mInternal Compiler Error:\e[0m"
  puts e.message
  puts e.backtrace[0..10].join("\n")
  exit 1
end
