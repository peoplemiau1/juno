#!/usr/bin/env ruby
# Juno CLI

require 'fileutils'
require 'tempfile'

JUNO_ROOT = File.dirname(File.realpath(__FILE__))
USER_DIR = Dir.pwd

def load_compiler
  Dir.chdir(JUNO_ROOT)
  require_relative "src/lexer"
  require_relative "src/parser"
  require_relative "src/importer"
  require_relative "src/monomorphizer"
  require_relative "src/optimizer/optimizer"
  require_relative "src/codegen/native_generator"
  require_relative "src/errors"
  begin
    require_relative "src/preprocessor"
  rescue LoadError
  end
end

$hell_mode = nil

def enable_hell_mode
  require_relative "src/polymorph/hell_mode"
  $hell_mode = HellMode.new(:hell)
end

def compile(input_file, output_path)
  load_compiler
  
  unless File.exist?(input_file)
    $stderr.puts "Error: #{input_file} not found"
    exit 1
  end
  
  code = File.read(input_file)
  lines = code.lines
  
  begin
    if defined?(Preprocessor)
      pp = Preprocessor.new
      pp.define("LINUX")
      code = pp.process(code, input_file)
    end
    
    lexer = Lexer.new(code, input_file)
    tokens = lexer.tokenize

    parser = Parser.new(tokens, input_file, code)
    ast = parser.parse

    importer = Importer.new(File.dirname(File.expand_path(input_file)))
    ast = importer.resolve(ast, input_file)

    mono = Monomorphizer.new(ast)
    ast = mono.monomorphize

    opt = Optimizer.new(ast)
    ast = opt.optimize

    gen = NativeGenerator.new(ast, :linux)
    gen.hell_mode = $hell_mode if $hell_mode
    
    FileUtils.mkdir_p(File.dirname(output_path))
    gen.generate(output_path)
    File.chmod(0755, output_path)
    
    output_path
    
  rescue JunoError => e
    e.display
    exit 1
  rescue => e
    msg = e.message
    if msg =~ /line (\d+)/i
      ln = $1.to_i
      $stderr.puts "\nError in #{input_file}:#{ln}\n"
      $stderr.puts "  #{ln} | #{lines[ln-1]&.chomp}"
      $stderr.puts "      | ^"
      $stderr.puts "\n#{msg}\n"
    else
      $stderr.puts "\nError: #{msg}\n"
    end
    exit 1
  end
end

def cmd_run(args)
  file = args.find { |a| a.end_with?(".juno") }
  enable_hell_mode if args.include?("--hell")
  
  unless file
    puts "Usage: juno run <file.juno>"
    exit 1
  end
  
  input = File.expand_path(file, USER_DIR)
  tmp = "/tmp/juno_#{$$}"
  
  compile(input, tmp)
  system(tmp)
  code = $?.exitstatus
  
  File.delete(tmp) if File.exist?(tmp)
  exit code
end

def cmd_build(args)
  file = nil
  output = nil
  
  i = 0
  while i < args.length
    if args[i] == "-o"
      i += 1
      output = args[i]
    elsif args[i] == "--hell"
      enable_hell_mode
    elsif args[i].end_with?(".juno")
      file = args[i]
    end
    i += 1
  end
  
  unless file
    puts "Usage: juno build <file.juno> [-o name]"
    exit 1
  end
  
  input = File.expand_path(file, USER_DIR)
  output ||= File.basename(file, ".juno")
  output_path = File.expand_path(output, USER_DIR)
  
  compile(input, output_path)
  puts output_path
end

def cmd_new(args)
  name = args[0] || "main"
  name += ".juno" unless name.end_with?(".juno")
  path = File.expand_path(name, USER_DIR)
  
  if File.exist?(path)
    puts "Error: #{name} exists"
    exit 1
  end
  
  File.write(path, <<~CODE)
    fn main(): int {
        print("Hello!")
        return 0
    }
  CODE
  
  puts name
end

def cmd_test(args)
  Dir.chdir(JUNO_ROOT)
  system("bash", "run_juno_tests.sh")
end

def cmd_help
  puts <<~HELP
  Juno

  juno run <file>         Run program
  juno build <file>       Compile to binary  
  juno build <f> -o name  Compile with custom name
  juno new <name>         Create new file
  juno test               Run tests
  juno help               Show help

  Options:
    --hell                Obfuscation mode

  HELP
end

# Main
cmd = ARGV[0]
args = ARGV[1..] || []

case cmd
when "run", "r"    then cmd_run(args)
when "build", "b"  then cmd_build(args)
when "new", "n"    then cmd_new(args)
when "test", "t"   then cmd_test(args)
when "help", "-h"  then cmd_help
when nil           then cmd_help
else
  if cmd.end_with?(".juno")
    cmd_run([cmd] + args)
  else
    puts "Unknown: #{cmd}"
    exit 1
  end
end
