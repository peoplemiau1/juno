#!/usr/bin/env ruby
# Unified Juno CLI - v3.0 Architecture (Industrial Edition)

require 'optparse'
require 'fileutils'
require_relative "src/frontend/lexer"
require_relative "src/frontend/parser"
require_relative "src/middle/importer"
require_relative "src/middle/monomorphizer"
require_relative "src/middle/semantic"
require_relative "src/middle/ir_generator"
require_relative "src/optimizer/turbo"
require_relative "src/middle/analyzer/resource_auditor"
require_relative "src/backend/hellion"
require_relative "src/frontend/preprocessor"
require_relative "src/errors"

options = {
  arch: :x86_64,
  os: :linux,
  output: nil,
  run: false
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: juno [options] <input_file>"
  opts.on("-a", "--arch ARCH", [:x86_64, :aarch64], "Target architecture") { |a| options[:arch] = a }
  opts.on("-o", "--output FILE", "Output binary path") { |o| options[:output] = o }
  opts.on("-t", "--target OS", [:linux, :flat], "Target OS") { |t| options[:os] = t }
  opts.on("-r", "--run", "Run after compilation") { options[:run] = true }
end

parser.parse!

if ARGV.empty?
  puts parser
  exit
end

input_file = ARGV[0]
output_path = options[:output] || "build/output"
FileUtils.mkdir_p("build")

begin
  # 1. FRONTEND: Text -> AST
  code = File.read(input_file)

  preprocessor = Preprocessor.new
  preprocessor.define(options[:os].to_s.upcase)
  preprocessor.define("__JUNO__")
  code = preprocessor.process(code, input_file)

  lexer = Lexer.new(code, input_file)
  tokens = lexer.tokenize
  parser = Parser.new(tokens, input_file, code)
  ast = parser.parse

  # 2. MIDDLE-END: AST -> IR (includes analysis and optimization)
  importer = Importer.new(File.dirname(input_file), system_path: File.join(__dir__, "stdlib"))
  ast = importer.resolve(ast, input_file)

  monomorphizer = Monomorphizer.new(ast)
  ast = monomorphizer.monomorphize

  analyzer = SemanticAnalyzer.new(ast, input_file, code)
  ast = analyzer.analyze

  optimizer = TurboOptimizer.new(ast)
  ast = optimizer.optimize

  # Resource auditing
  func_signatures = {}
  ast.each { |node| func_signatures[node[:name]] = node[:return_type] if node[:type] == :function_definition }
  auditor = ResourceAuditor.new(ast, func_signatures, code, input_file)
  auditor.audit

  ir_gen = IRGenerator.new
  ir = ir_gen.generate(ast)

  # 3. BACKEND (Hellion): IR -> Binary
  backend = Hellion.new(options[:arch], options[:os])
  backend.generate(ir, output_path)

  puts "Success! Compiled to #{output_path}"

  if options[:run] && options[:os] == :linux
    puts "Executing..."
    exec("./#{output_path}")
  end

rescue JunoError => e
  e.display
  exit 1
rescue Interrupt
  exit 1
rescue => e
  puts "Internal Compiler Error: #{e.message}"
  puts e.backtrace
  exit 1
end
