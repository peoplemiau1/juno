#!/usr/bin/env ruby
# Juno Language CLI

require 'fileutils'

JUNO_ROOT = File.dirname(File.realpath(__FILE__))
USER_DIR = Dir.pwd

def load_compiler
  Dir.chdir(JUNO_ROOT)
  require_relative "src/lexer"
  require_relative "src/parser"
  require_relative "src/importer"
  require_relative "src/monomorphizer"
  require_relative "src/optimizer/optimizer"
  require_relative "src/codegen/native_generator"
  require_relative "src/preprocessor"
  require_relative "src/errors"
end

$hell_mode = nil

def enable_hell_mode(level = :hell)
  require_relative "src/polymorph/hell_mode"
  $hell_mode = HellMode.new(level)
  puts "[HELL MODE] Level: #{level}"
end

def compile(input_file, options = {})
  load_compiler
  
  unless File.exist?(input_file)
    puts "Error: File not found: #{input_file}"
    exit 1
  end
  
  output_name = options[:output] || "output"
  target = options[:target] || :linux
  
  code = File.read(input_file)
  
  puts "Compiling #{input_file}..." unless options[:quiet]
  
  begin
    preprocessor = Preprocessor.new
    preprocessor.define("LINUX")
    code = preprocessor.process(code, input_file)
    
    lexer = Lexer.new(code, input_file)
    tokens = lexer.tokenize

    parser = Parser.new(tokens, input_file, code)
    ast = parser.parse

    importer = Importer.new(File.dirname(File.expand_path(input_file)))
    ast = importer.resolve(ast, input_file)

    monomorphizer = Monomorphizer.new(ast)
    ast = monomorphizer.monomorphize

    optimizer = Optimizer.new(ast)
    ast = optimizer.optimize

    generator = NativeGenerator.new(ast, target)
    generator.hell_mode = $hell_mode if $hell_mode
    
    FileUtils.mkdir_p("#{JUNO_ROOT}/build")
    output_path = File.join("#{JUNO_ROOT}/build", output_name)
    generator.generate(output_path)
    
    File.chmod(0755, output_path)
    
    unless options[:quiet]
      puts "OK: #{output_path}"
      $hell_mode.report if $hell_mode
    end
    
    output_path
  rescue JunoError => e
    e.display
    exit 1
  rescue => e
    puts "Error: #{e.message}"
    exit 1
  end
end

def cmd_build(args)
  options = {}
  files = []
  
  i = 0
  while i < args.length
    arg = args[i]
    case arg
    when "--hell"
      enable_hell_mode(:hell)
    when "--obfuscate"
      enable_hell_mode(:hard)
    when "-o"
      i += 1
      options[:output] = args[i]
    when "-q", "--quiet"
      options[:quiet] = true
    when /^-/
      # skip unknown
    else
      files << arg
    end
    i += 1
  end
  
  if files.empty?
    puts "Usage: juno build <file.juno> [-o name] [--hell]"
    exit 1
  end
  
  input_file = File.expand_path(files[0], USER_DIR)
  compile(input_file, options)
end

def cmd_run(args)
  options = {}
  files = []
  
  args.each do |arg|
    case arg
    when "--hell"
      enable_hell_mode(:hell)
    when /^-/
      # ignore
    else
      files << arg
    end
  end
  
  if files.empty?
    puts "Usage: juno run <file.juno>"
    exit 1
  end
  
  input_file = File.expand_path(files[0], USER_DIR)
  binary = compile(input_file, options)
  
  puts "Running..."
  puts "-" * 40
  system(binary)
  code = $?.exitstatus
  puts "-" * 40
  puts "Exit: #{code}"
end

def cmd_test(args)
  Dir.chdir(JUNO_ROOT)
  
  if args.empty?
    system("bash", "run_juno_tests.sh")
  else
    args.each do |test|
      test_file = "tests/test_#{test}.juno"
      test_file = "tests/#{test}.juno" unless File.exist?(test_file)
      test_file = test if test.end_with?(".juno")
      
      if File.exist?(test_file)
        puts "Testing #{test_file}..."
        binary = compile(test_file, { quiet: true, output: "test_out" })
        system(binary)
        puts $?.exitstatus == 0 ? "PASS" : "FAIL"
      else
        puts "Not found: #{test}"
      end
    end
  end
end

def cmd_new(args)
  name = args[0] || "main"
  filename = name.end_with?(".juno") ? name : "#{name}.juno"
  filepath = File.expand_path(filename, USER_DIR)
  
  if File.exist?(filepath)
    puts "Error: #{filename} already exists"
    exit 1
  end
  
  template = <<~JUNO
    fn main(): int {
        print("Hello, Juno!")
        return 0
    }
  JUNO
  
  File.write(filepath, template)
  puts "Created: #{filename}"
end

def cmd_version
  puts "Juno v1.6"
  puts "Targets: Linux ELF, Windows PE (x86-64)"
end

def cmd_help
  puts <<~HELP
  Juno Compiler
  
  Usage: juno <command> [options]
  
  Commands:
    build <file>     Compile to binary
    run <file>       Compile and run
    test [name]      Run tests
    new <name>       Create new file
    version          Show version
    help             Show this help
  
  Build options:
    -o <name>        Output name
    -q               Quiet mode
    --hell           Obfuscation (anti-RE)
  
  Examples:
    juno build hello.juno
    juno build app.juno -o myapp
    juno run hello.juno
    juno new myproject
  
  Update:
    cd #{JUNO_ROOT} && git pull
  
  HELP
end

# Main
command = ARGV[0]
args = ARGV[1..] || []

case command
when "build", "b"
  cmd_build(args)
when "run", "r"
  cmd_run(args)
when "test", "t"
  cmd_test(args)
when "new", "n"
  cmd_new(args)
when "version", "-v", "--version"
  cmd_version
when "help", "-h", "--help", nil
  cmd_help
else
  if command&.end_with?(".juno")
    cmd_run([command] + args)
  else
    puts "Unknown: #{command}"
    puts "Run: juno help"
    exit 1
  end
end
