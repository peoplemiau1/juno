# Управление памятью и ресурсы

## 1. Ownership Auditor (Born -> Kill)
В Juno  введена система автоматического аудита владения ресурсами. Это уникальная фича, которая предотвращает утечки памяти и `use-after-free` на этапе компиляции.

**Правила:**
1.  **Создание (Born)**: Функции `malloc`, `json_loads`, `str_new`, `vec_new` и `arena_new` создают новый ресурс.
2.  **Передача**: Если вы передаете ресурс в функцию, которая его потребляет (например, `vec_push` или `str_free`), вы больше не можете его использовать в текущем контексте.
3.  **Уничтожение (Kill)**: Каждый созданный ресурс должен быть освобожден функцией `free` или её аналогом в той же области видимости, где он был создан (если он не был передан дальше).

**Пример ошибки E0007:**
```juno
fn test() {
    let p = malloc(16)
    // ОШИБКА: p не освобожден (Leak)
}
```

## 2. Динамическая память (Куча)
Juno использует собственный минималистичный аллокатор поверх `mmap`.
*   `malloc(size)`: Выделяет блок + 8 байт заголовка для хранения размера.
*   `realloc(ptr, size)`: Перевыделяет память и копирует данные.
*   `free(ptr)`: Освобождает память. Если вызвать без размера, Juno возьмет его из заголовка.

## 3. Arena Allocator
Для высокопроизводительных приложений рекомендуется использовать `std/arena`. Арена позволяет выделять множество мелких объектов и освобождать их все одним вызовом.

```juno
import std/arena
let a = arena_new(4096)
let s1 = arena_str(a, "first")
let s2 = arena_str(a, "second")
arena_free(a) // Очистит s1 и s2
```

## 4. Стек и Регистры
*   **Регистры**: Локальные переменные по умолчанию живут в регистрах (`RBX, R12-R15`).
*   **Стек**: Если вы берете адрес переменной (`&x`), компилятор перемещает её из регистра в стек.
*   **Выравнивание**: Весь код Juno соблюдает 16-байтовое выравнивание стека для совместимости с внешними библиотеками и SIMD-инструкциями.
