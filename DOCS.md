# Техническое руководство Juno

## Содержание
1. [Спецификация типов](#спецификация-типов)
2. [Синтаксис и конструкции](#синтаксис-и-конструкции)
3. [Архитектура памяти и владение](#архитектура-памяти-и-владение)
4. [Модель выполнения и регистры](#модель-выполнения-и-регистры)
5. [Обфускация (Hell Mode)](#обфускация)
6. [Стандартная библиотека](#стандартная-библиотека)
7. [Интерфейс системных вызовов](#системные-вызовы)

---

## 1. Спецификация типов

Juno является языком с сильной типизацией и явным управлением представлением данных в памяти.

| Тип | Размер | Описание |
|-----|--------|----------|
| `int` | 64 бит | Знаковое целое число |
| `ptr` | 64 бит | Нетипизированный указатель |
| `bool`| 8 бит  | Логическое значение (0 или 1) |
| `real`| 64 бит | Число с плавающей запятой (зарезервировано) |
| `string`| 64 бит | Указатель на последовательность байт (u8*) |

### Составные типы
- **Struct**: Набор именованных полей.
- **Enum**: Тегированное объединение (Tagged Union).
- **Array**: Фиксированный набор элементов в памяти.

---

## 2. Синтаксис и конструкции

### Переменные и Мутабельность
По умолчанию переменные неизменяемы.
```watt
let x = 10        // Константа
let mut y = 20    // Переменная
y = 30            // Допустимо
x = 5             // Ошибка компиляции
```

### Управляющие конструкции
- **if / elif / else**: Стандартное ветвление.
- **while**: Цикл с предусловием.
- **loop**: Бесконечный цикл.
- **for**: Итерация по диапазону или коллекции.

### Pattern Matching (Сопоставление с образцом)
Используется для разбора Enum и сложных структур.
```watt
match expression {
    Variant1(val) => { ... },
    Variant2 => { ... },
    _ => { ... } // Default case
}
```

---

## 3. Архитектура памяти и владение

### Resource Ownership Auditor (ROA)
Juno реализует модель статического контроля ресурсов. Каждая переменная, хранящая результат аллокации, является **владельцем** ресурса.

**Правила владения:**
1. **Move Semantics**: При присваивании указателя новой переменной или передаче в функцию (не входящую в `exempt`-список), владение переходит к получателю. Использование исходной переменной после этого вызывает ошибку `E0007`.
2. **Explicit Free**: Программист обязан явно освободить ресурс. Если в конце области видимости ресурс не был потреблен или освобожден, генерируется предупреждение о потенциальной утечке.

---

## 4. Модель выполнения и регистры

### Реестровая аллокация
Juno использует алгоритм **Linear Scan** для распределения переменных по физическим регистрам.

**x86-64 mapping:**
- `RBX, R12-R15`: Callee-saved (сохраняются между вызовами).
- `R10, R11`: Caller-saved (scratch).
- `RAX`: Возвращаемое значение.

### Выравнивание стека
Для обеспечения совместимости с нативными C-библиотеками (FFI), Juno гарантирует **16-байтовое выравнивание стека** (RSP % 16 == 0) перед каждой инструкцией `call`.

---

## 5. Обфускация (Hell Mode)

Интегрированный движок мутации кода.
- **Junk Code Injection**: Внедрение "мусорных" инструкций, которые не меняют логику, но усложняют статический анализ.
- **Instruction Mutation**: Замена одних последовательностей инструкций на другие, эквивалентные по результату.
- **Strict Decoder**: Собственный декодер инструкций позволяет безопасно модифицировать бинарный код.

---

## 6. Стандартная библиотека

### `std/json`
- `json_loads(data: ptr)`: Парсинг строки в объект.
- `json_get(obj: ptr, key: string)`: Получение значения по ключу.

### `std/arena`
- `arena_new(initial_size: int)`: Создание арены.
- `arena_alloc(a: ptr, sz: int)`: Быстрая аллокация в арене.

---

## 7. Интерфейс системных вызовов

Прямой доступ к ядру через `syscall`. Номера вызовов автоматически транслируются для целевой архитектуры.

```juno
// x86_64: write(1, buf, len)
syscall(1, 1, buffer, length)
```
