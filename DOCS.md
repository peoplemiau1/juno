# Техническое руководство Juno v2.1

## Содержание
1. [Спецификация типов](#спецификация-типов)
2. [Архитектура памяти и владение](#архитектура-памяти-и-владение)
3. [Модель выполнения и регистры](#модель-выполнения-и-регистры)
4. [Метаморфическая защита (Hell Mode)](#метаморфическая-защита)
5. [Стандартная библиотека](#стандартная-библиотека)
6. [Интерфейс системных вызовов](#системные-вызовы)

---

## 1. Спецификация типов

Juno является языком с сильной типизацией и явным управлением представлением данных в памяти.

| Тип | Размер | Описание |
|-----|--------|----------|
| `int` | 64 бит | Знаковое целое число (архитектурно-зависимое, по умолчанию i64) |
| `ptr` | 64 бит | Нетипизированный указатель (адрес в виртуальной памяти) |
| `bool`| 8 бит  | Логическое значение (0 или 1) |
| `i8..i64` | 8..64 | Знаковые целые числа фиксированной длины |
| `u8..u64` | 8..64 | Беззнаковые целые числа фиксированной длины |

---

## 2. Архитектура памяти и владение

### Resource Ownership Auditor (ROA)
В Juno v2.1 реализована модель статического контроля ресурсов. Каждая переменная, хранящая результат аллокации, является **владельцем** ресурса.

**Жизненный цикл (Born -> Kill):**
-   **Born**: Ресурс создается через `malloc`, `json_loads` или `arena_new`. Анализатор помечает переменную как активную.
-   **Transfer**: Передача переменной в функцию, не входящую в список исключений, считается передачей владения. Текущая переменная становится невалидной (Use-After-Free check).
-   **Kill**: Ресурс должен быть явно освобожден через `free` или `arena_free`.

При нарушении правил компилятор генерирует ошибку `E0007`.

---

## 3. Модель выполнения и регистры

### Реестровая аллокация
Juno использует алгоритм **Linear Scan** для оптимального распределения переменных по физическим регистрам.

**Приоритет использования регистров (x86-64):**
1.  `RBX, R12, R13, R14, R15` — Долгоживущие переменные (Callee-saved).
2.  `R10, R11` — Временные вычисления (Scratch).
3.  `RAX, RCX, RDX` — Аргументы системных вызовов и возвращаемые значения.

### Выравнивание стека
Для обеспечения совместимости с нативными C-библиотеками и корректной работы векторных инструкций (SSE/AVX/NEON), Juno гарантирует **16-байтовое выравнивание стека** перед каждой инструкцией `call`.

---

## 4. Метаморфическая защита (Hell Mode)

Hell Mode — это интегрированный в компилятор движок обфускации.

-   **Precise Decoding**: В отличие от конкурентов, Juno содержит полноценный декодер длин инструкций x86-64, что позволяет внедрять мусорный код (junk code) непосредственно между функциональными инструкциями без риска повреждения логики.
-   **Control Flow Flattening**: (В разработке) Размытие графа управления программой.
-   **String Encryption**: Автоматическое XOR-шифрование статических строк в секции `.data`.

---

## 5. Стандартная библиотека

### `std/json`
Реализация высокоскоростного парсера.
-   `json_loads(ptr)`: Парсинг сырой строки в AST-дерево.
-   `json_get(node, key)`: Поиск по ключу в O(N).
-   `json_free(node)`: Рекурсивное освобождение памяти.

### `std/arena`
Регионный аллокатор для исключения фрагментации кучи и ускорения выделения памяти.
-   `arena_new(size)`: Создание пула.
-   `arena_alloc(arena, size)`: Выделение за O(1) через инкремент указателя.
-   `arena_free(arena)`: Мгновенное освобождение всех объектов в пуле.

---

## 6. Интерфейс системных вызовов

Juno предоставляет прямой доступ к ядру Linux через встроенную функцию `syscall`.

```juno
// Пример: вызов write(stdout, buf, len) на x86_64
syscall(1, 1, buffer, length)
```

Маппинг системных вызовов для `x86_64` и `aarch64` доступен в `src/codegen/parts/syscall_mapper.rb`.
