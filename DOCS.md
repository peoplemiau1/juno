# Juno v2.0 - Документация

> **Важно**: Для детального изучения каждой темы обратитесь к разделу [Подробная документация](docs/):
> *   [Синтаксис](docs/syntax.md)
> *   [Функции и Generics](docs/functions.md)
> *   [Управление памятью](docs/memory.md)
> *   [Стандартная библиотека](docs/stdlib.md)
> *   [Системные вызовы](docs/syscalls.md)
> *   [Оптимизатор](docs/optimizer.md)
> *   [Обфускация](docs/obfuscation.md)
> *   [Архитектура](docs/architecture.md)
> *   [CLI](docs/cli.md)

## Содержание

1. [Установка](#установка)
2. [Синтаксис](#синтаксис)
3. [Встроенные функции](#встроенные-функции)
4. [Стандартная библиотека](#стандартная-библиотека)
5. [Сеть и HTTP](#сеть-и-http)
6. [Системные вызовы](#системные-вызовы)
7. [Многопоточность](#многопоточность)
8. [Оптимизатор](#оптимизатор)
9. [Обфускация](#обфускация)
10. [Примеры](#примеры)
11. [Рекомендации и идиомы](#рекомендации-и-идиомы)

---

## Установка

```bash
git clone https://github.com/peoplemiau1/juno.git
cd juno && ./install.sh && source ~/.bashrc
```

**CLI:**
```bash
juno run file.juno          # запустить
juno build file.juno -o app # скомпилировать (x86_64)
juno build file.juno --arch aarch64 -o app_arm # скомпилировать для ARM64
juno build file.juno --hell # с обфускацией
juno new name               # создать файл
```

---

## Что нового в v2.1 "Architectural Integrity"

1.  **Реестровый аллокатор (Linear Scan)**: Теперь Juno эффективно использует регистры процессора (`RBX, R12-R15` на x86_64 и `X19-X28` на AArch64).
2.  **Ownership Auditor (E0007)**: Строгий контроль ресурсов. Правило «Родил -> Убил». Утечки памяти теперь детектируются на этапе компиляции.
3.  **Глобальные переменные**: Поддержка `let` на верхнем уровне.
4.  **Compiler UX**: Красивые сообщения об ошибках с контекстом кода.
5.  **Standard Library v3**: Модули `std/str`, `std/vec`, `std/json`, `std/net`, `std/arena`.
6.  **Hardened Hell Mode**: Прецизионный декодер инструкций x86-64.

---

## Синтаксис

### Функции

```juno
// Три способа объявить функцию:
fn add(a: int, b: int): int { return a + b }
func add(a: int, b: int): int { return a + b }
def add(a: int, b: int): int { return a + b }
```

### Переменные

```juno
x = 10              // локальная переменная (авто-регистр)
let y = 20          // явное объявление
let arr[5]          // массив на стеке (16-байт выравнивание)

// Глобальные переменные (вне функций)
let GLOBAL_BUF[1024]
let VERSION = 2
```

### Условия и циклы

```juno
// Скобки опциональны:
if x > 5 { ... }
if (x > 5) { ... }    // тоже работает

while x < 10 { x = x + 1 }
while (x < 10) { ... } // тоже работает

for (i = 0; i < 10; i++) { ... }
// Новое в v2.0: объявление переменной в цикле
for (let i = 0; i < 10; i++) { ... }
```

### Математические операторы

Поддерживаются стандартные операторы: `+`, `-`, `*`, `/` и **`%` (остаток от деления)**.

### Указатели

```juno
ptr = &x        // адрес
val = *ptr      // разыменование
*ptr = 100      // запись по адресу
```

---

## Встроенные функции

### I/O

| Функция | Описание |
|---------|----------|
| `print(n)` | Вывести число |
| `prints(s)` | Вывести строку |
| `input()` | Читать строку |
| `read(fd, buf, n)` | Читать из fd |
| `write(fd, buf, n)` | Писать в fd |
| `open(path, flags)` | Открыть файл |
| `close(fd)` | Закрыть fd |
| `len(arr)` | Размер массива или строки |

### Строки

| Функция | Описание |
|---------|----------|
| `str_len(s)` | Длина |
| `concat(a, b)` | Объединить (также через `+`) |
| `substr(s, start, len)` | Подстрока |
| `itoa(n)` | 42 → "42" |
| `atoi(s)` | "42" → 42 |
| `str_cmp(a, b)` | Сравнить (0=равны) |

### Память

| Функция | Описание |
|---------|----------|
| `malloc(size)` | Выделить кучу |
| `free(ptr)` | Освободить |
| `realloc(ptr, size)` | Изменить размер |
| `memset(ptr, val, n)` | Заполнить |
| `memcpy(dst, src, n)` | Копировать |

---

## Стандартная библиотека

Находится в `stdlib/std.juno`. Подключается через `import "stdlib/std.juno"`.

### Структуры данных

- `List` - Динамический массив
- `Stack` - Стек (LIFO)
- `Queue` - Очередь (FIFO)

### Алгоритмы

- `bubble_sort(arr, len)` - Сортировка пузырьком
- `is_prime(n)` - Проверка на простое число
- `ipow(base, exp)` - Быстрое возведение в степень

---

## Сеть и HTTP

### Сокеты

```juno
sock = socket(2, 1, 0)        // AF_INET, SOCK_STREAM
bind(sock, ip(0,0,0,0), 8080)
listen(sock, 10)
client = accept(sock)
send(client, "Hi", 2)
recv(client, buf, 4096)
close(client)
```

---

## Системные вызовы

Полная поддержка системных вызовов на **x86_64** и **AArch64**.

| Функция | Описание |
|---------|----------|
| `fork()` | Создать процесс |
| `exit(code)` | Завершить |
| `getpid()` | PID |
| `kill(pid, sig)` | Сигнал |
| `execve(path, argv, env)` | Запустить |
| `syscall(num, ...)` | Прямой вызов (архитектурно-зависимый) |

---

## Многопоточность

```juno
fn worker(arg) {
    print(arg)
}

fn main() {
    stack = alloc_stack(65536)
    tid = thread_create(&worker, stack, 42)
    return 0
}
```

---

## Оптимизатор

Turbo Optimizer включает:
- Инлайнинг функций
- Развёртка циклов
- Удаление общих подвыражений (CSE)
- Strength reduction (mul→shift, div→shift)

---

## Обфускация

```bash
juno build app.juno --hell
```

Hell Mode v2.0 включает улучшенную полиморфную генерацию и защиту от отладки.

---

## Обновление

```bash
cd ~/juno && git pull
```

---

## 11. Управление регистрами (Техническое)

Juno v2.1 автоматически управляет регистрами процессора:
- **Локальные переменные**: Приоритетно размещаются в `RBX, R12, R13, R14, R15` на x86_64 и в `X19-X28` на AArch64.
- **Стек**: Используется только при "spilling" (нехватке регистров) или если у переменной взят адрес (`&x`).
- **Выравнивание**: Стек всегда выравнивается по 16 байт перед вызовом функций (ABI compliance).

---

## 12. Рекомендации и идиомы

### Управление ресурсами (Born -> Kill)
В Juno v2.1 введена строгая проверка владения ресурсами. Если вы вызываете `malloc` или `json_loads`, вы **обязаны** либо передать этот указатель в функцию (которая возьмет владение), либо вызвать `free` в той же области видимости.

```juno
fn process() {
    let data = malloc(1024)
    // ... работаем ...
    free(data) // ОБЯЗАТЕЛЬНО
}
```

### Использование Arena Allocator
Для сложных графов объектов или временных строк используйте `std/arena`. Это избавит вас от ручного вызова `free` для каждого мелкого объекта.

```juno
import std/arena

fn main() {
    let a = arena_new(1024 * 1024) // 1MB
    let s = arena_str(a, "Temporary string")
    // ...
    arena_free(a) // Очистит всё сразу
}
```

### Регистры vs Стек
Избегайте использования оператора адреса (`&x`) для простых переменных, если это не необходимо. Взятие адреса заставляет переменную "осесть" на стеке, лишая её преимуществ реестрового аллокатора.

```juno
let x = 42
do_something(x)  // x в регистре RBX (быстро)

let y = 100
let p = &y       // y теперь на стеке (медленнее)
```
