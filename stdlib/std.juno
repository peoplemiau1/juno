// stdlib/std.juno - Juno Standard Library

// === Math Functions ===

fn square(x) {
    return x * x
}

fn cube(x) {
    return x * x * x
}

fn abs_val(x) {
    if (x < 0) {
        return 0 - x
    }
    return x
}

fn min_val(a, b) {
    if (a < b) {
        return a
    }
    return b
}

fn max_val(a, b) {
    if (a > b) {
        return a
    }
    return b
}

fn clamp(x, lo, hi) {
    if (x < lo) {
        return lo
    }
    if (x > hi) {
        return hi
    }
    return x
}

fn factorial(n) {
    let result = 1
    for (i = 1; i <= n; i++) {
        result = result * i
    }
    return result
}

fn fib(n) {
    if (n <= 1) {
        return n
    }
    let a = 0
    let b = 1
    for (i = 2; i <= n; i++) {
        let tmp = a + b
        a = b
        b = tmp
    }
    return b
}

fn gcd(a, b) {
    while (b != 0) {
        let tmp = b
        b = a % b
        a = tmp
    }
    return a
}

fn is_prime(n) {
    if (n <= 1) { return 0 }
    if (n <= 3) { return 1 }
    if (n % 2 == 0) { return 0 }
    if (n % 3 == 0) { return 0 }
    let i = 5
    while (i * i <= n) {
        if (n % i == 0) { return 0 }
        if (n % (i + 2) == 0) { return 0 }
        i = i + 6
    }
    return 1
}

fn ipow(base, exp) {
    let res = 1
    while (exp > 0) {
        if (exp % 2 == 1) { res = res * base }
        base = base * base
        exp = exp / 2
    }
    return res
}

// === System call wrappers (Linux builtins) ===

// Common constants
fn OS_O_RDONLY() { return 0 }
fn OS_O_WRONLY() { return 1 }
fn OS_O_RDWR()   { return 2 }
fn OS_O_CREAT()  { return 64 }
fn OS_O_TRUNC()  { return 512 }

fn OS_AF_INET()     { return 2 }
fn OS_SOCK_STREAM() { return 1 }
fn OS_SOCK_DGRAM()  { return 2 }

fn OS_PROT_READ()  { return 1 }
fn OS_PROT_WRITE() { return 2 }

fn OS_MAP_PRIVATE()   { return 2 }
fn OS_MAP_ANONYMOUS() { return 32 }

// File I/O
fn os_open(path) {
    return open(path)
}

fn os_read(fd, buf, size) {
    return read(fd, buf, size)
}

fn os_write(fd, buf, size) {
    return write(fd, buf, size)
}

fn os_close(fd) {
    return close(fd)
}

// Process and time
fn os_exit(code) {
    exit(code)
}

fn os_sleep(ms) {
    sleep(ms)
}

fn os_time() {
    return time()
}

// Memory management
fn os_alloc(size) {
    return alloc(size)
}

fn os_free(ptr, size) {
    free(ptr, size)
}

// Generic syscall helpers (up to 4 args)
fn os_syscall1(num, a1) {
    return syscall(num, a1)
}

fn os_syscall2(num, a1, a2) {
    return syscall(num, a1, a2)
}

fn os_syscall3(num, a1, a2, a3) {
    return syscall(num, a1, a2, a3)
}

fn os_syscall4(num, a1, a2, a3, a4) {
    return syscall(num, a1, a2, a3, a4)
}

// Networking
fn os_socket(domain, type, protocol) {
    return socket(domain, type, protocol)
}

fn os_connect(sockfd, ip_addr, port) {
    return connect(sockfd, ip_addr, port)
}

fn os_send(sockfd, buf, len) {
    return send(sockfd, buf, len)
}

fn os_recv(sockfd, buf, len) {
    return recv(sockfd, buf, len)
}

fn os_bind(sockfd, ip_addr, port) {
    return bind(sockfd, ip_addr, port)
}

fn os_listen(sockfd, backlog) {
    return listen(sockfd, backlog)
}

fn os_accept(sockfd) {
    return accept(sockfd)
}

fn os_ip(a, b, c, d) {
    return ip(a, b, c, d)
}

// === Utility Structures ===

struct Pair {
    let first
    let second
}

fn Pair.init(a, b) {
    self.first = a
    self.second = b
}

fn Pair.swap() {
    let tmp = self.first
    self.first = self.second
    self.second = tmp
}

// === File I/O wrappers ===
// Note: uses low-level syscalls via builtin syscall

fn os_open_sys(path, flags, mode) {
    return syscall(2, path, flags, mode)
}

fn os_read_file(path, buf, size) {
    let fd = os_open_sys(path, OS_O_RDONLY(), 0)
    if (fd < 0) { return fd }
    let n = read(fd, buf, size)
    close(fd)
    let p = ptr_add(buf, n)
    *p = 0
    return n
}

fn os_write_file(path, buf, len) {
    let flags = OS_O_CREAT() | OS_O_TRUNC() | OS_O_WRONLY()
    let fd = os_open_sys(path, flags, 420)  // 0644
    if (fd < 0) { return fd }
    let n = write(fd, buf, len)
    close(fd)
    return n
}

// === String Functions ===

fn str_empty(s) {
    if s == 0 { return 1 }
    if *s == 0 { return 1 }
    return 0
}

fn str_equals(s1, s2) {
    return str_cmp(s1, s2) == 0
}

// === High-level abstractions ===

struct List {
    let data
    let len
    let cap
}

fn List.init(capacity) {
    if capacity <= 0 { capacity = 1 }
    self.data = malloc(capacity * 8)
    self.len = 0
    self.cap = capacity
}

fn List.add(val) {
    if self.len == self.cap {
        let new_cap = self.cap * 2
        self.data = realloc(self.data, new_cap * 8)
        self.cap = new_cap
    }
    let p = ptr_add(self.data, self.len)
    *p = val
    self.len = self.len + 1
}

fn List.get(index) {
    if index < 0 { return 0 }
    if index >= self.len { return 0 }
    let p = ptr_add(self.data, index)
    return *p
}

fn List.size() {
    return self.len
}

struct Stack {
    let items
}

fn Stack.init() {
    let l = malloc(24) // size of List
    let items: List = l
    items.init(10)
    self.items = l
}

fn Stack.push(val) {
    let l: List = self.items
    l.add(val)
}

fn Stack.pop() {
    let l: List = self.items
    if (l.len == 0) { return 0 }
    l.len = l.len - 1
    let p = ptr_add(l.data, l.len)
    return *p
}

fn Stack.peek() {
    let l: List = self.items
    if (l.len == 0) { return 0 }
    let p = ptr_add(l.data, l.len - 1)
    return *p
}

struct Queue {
    let items
    let head
}

fn Queue.init() {
    let l = malloc(24)
    let items: List = l
    items.init(10)
    self.items = l
    self.head = 0
}

fn Queue.enqueue(val) {
    let l: List = self.items
    l.add(val)
}

fn Queue.dequeue() {
    let l: List = self.items
    if (self.head >= l.len) { return 0 }
    let p = ptr_add(l.data, self.head)
    let val = *p
    self.head = self.head + 1
    return val
}

// === Algorithms ===

fn bubble_sort(arr, len) {
    for (i = 0; i < len; i++) {
        for (j = 0; j < len - i - 1; j++) {
            let p1 = ptr_add(arr, j)
            let p2 = ptr_add(arr, j + 1)
            let v1 = *p1
            let v2 = *p2
            if (v1 > v2) {
                *p1 = v2
                *p2 = v1
            }
        }
    }
}
