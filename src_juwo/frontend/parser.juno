// src_juwo/frontend/parser.juno

enum NodeType {
    Literal,
    Variable,
    BinaryOp,
    FnCall,
    Assignment,
    IfStatement,
    WhileStatement,
    Return,
    Block,
    Let,
    Fn,
    Struct,
    Enum,
    For,
    Match,
    Import
}

struct Node {
    let kind: NodeType
    let data1: ptr
    let data2: ptr
    let data3: ptr
    let data4: ptr
}

struct Parser {
    let tokens: ptr // List
    let pos: int
}

fn Parser.init(tokens: ptr) {
    self.tokens = tokens
    self.pos = 0
}

fn Parser.peek(): ptr {
    let l: List = self.tokens
    return l.get(self.pos)
}

fn Parser.advance(): ptr {
    let t = self.peek()
    self.pos = self.pos + 1
    return t
}

fn Parser.match_kind(kind: TokenKind): bool {
    let t: Token = self.peek()
    return t.kind == kind
}

fn Parser.match_value(val: ptr): bool {
    let t: Token = self.peek()
    return str_equals(t.value, val)
}

fn Parser.consume(kind: TokenKind): ptr {
    if (self.match_kind(kind)) {
        return self.advance()
    }
    prints("Error: Unexpected token kind\n")
    exit(1)
    return 0
}

fn Parser.consume_value(kind: TokenKind, val: ptr): ptr {
    let t: Token = self.peek()
    if (t.kind == kind && str_equals(t.value, val)) {
        return self.advance()
    }
    prints("Error: Expected ")
    prints(val)
    prints("\n")
    exit(1)
    return 0
}

fn Parser.parse_expression(): ptr {
    return self.parse_equality()
}

fn Parser.parse_equality(): ptr {
    let mut expr = self.parse_comparison()
    while (self.match_value("==") || self.match_value("!=")) {
        let op = self.advance()
        let t: Token = op
        let right = self.parse_comparison()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.BinaryOp
        n.data1 = t.value
        n.data2 = expr
        n.data3 = right
        expr = node
    }
    return expr
}

fn Parser.parse_comparison(): ptr {
    let mut expr = self.parse_term()
    while (self.match_value("<") || self.match_value(">") || self.match_value("<=") || self.match_value(">=")) {
        let op = self.advance()
        let t: Token = op
        let right = self.parse_term()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.BinaryOp
        n.data1 = t.value
        n.data2 = expr
        n.data3 = right
        expr = node
    }
    return expr
}

fn Parser.parse_term(): ptr {
    let mut expr = self.parse_factor()
    while (self.match_value("+") || self.match_value("-")) {
        let op = self.advance()
        let t: Token = op
        let right = self.parse_factor()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.BinaryOp
        n.data1 = t.value
        n.data2 = expr
        n.data3 = right
        expr = node
    }
    return expr
}

fn Parser.parse_factor(): ptr {
    let mut expr = self.parse_primary()
    while (self.match_value("*") || self.match_value("/")) {
        let op = self.advance()
        let t: Token = op
        let right = self.parse_primary()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.BinaryOp
        n.data1 = t.value
        n.data2 = expr
        n.data3 = right
        expr = node
    }
    return expr
}

fn Parser.parse_primary(): ptr {
    if (self.match_kind(TokenKind.Number)) {
        let t: Token = self.advance()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.Literal
        n.data1 = t.value
        return node
    }

    if (self.match_kind(TokenKind.Ident)) {
        let t: Token = self.advance()
        if (self.match_value("(")) {
            // Function call
            self.advance() // skip (
            let args = malloc(24) // List
            let l: List = args
            l.init(5)
            while (!self.match_value(")") && !self.match_kind(TokenKind.EOF)) {
                l.add(self.parse_expression())
                if (self.match_value(",")) { self.advance() }
            }
            self.consume_value(TokenKind.Symbol, ")")

            let node = malloc(40)
            let n: Node = node
            n.kind = NodeType.FnCall
            n.data1 = t.value
            n.data2 = args
            return node
        }

        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.Variable
        n.data1 = t.value
        return node
    }

    if (self.match_value("(")) {
        self.advance()
        let expr = self.parse_expression()
        self.consume_value(TokenKind.Symbol, ")")
        return expr
    }

    prints("Error: Unexpected token in parse_primary: ")
    let t2: Token = self.peek()
    prints(t2.value)
    prints("\n")
    exit(1)
    return 0
}

fn Parser.parse_statement(): ptr {
    if (self.match_value("if")) {
        return self.parse_if()
    }
    if (self.match_value("while")) {
        return self.parse_while()
    }
    if (self.match_value("return")) {
        self.advance()
        let expr = self.parse_expression()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.Return
        n.data1 = expr
        return node
    }
    if (self.match_value("{")) {
        return self.parse_block_node()
    }
    if (self.match_value("let")) {
        return self.parse_let()
    }
    if (self.match_value("fn")) {
        return self.parse_fn()
    }
    if (self.match_value("for")) {
        return self.parse_for()
    }

    // Assignment or expression statement
    let expr = self.parse_expression()
    if (self.match_value("=")) {
        let t: Node = expr
        if (t.kind != NodeType.Variable) {
            prints("Error: LHS of assignment must be a variable\n")
            exit(1)
        }
        self.advance()
        let val = self.parse_expression()
        let node = malloc(40)
        let n: Node = node
        n.kind = NodeType.Assignment
        n.data1 = t.data1 // name
        n.data2 = val
        return node
    }
    return expr
}

fn Parser.parse_block_node(): ptr {
    let b = self.parse_block_list()
    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.Block
    n.data1 = b
    return node
}

fn Parser.parse_block_list(): ptr {
    self.consume_value(TokenKind.Symbol, "{")
    let stmts = malloc(24) // List
    let l: List = stmts
    l.init(10)
    while (!self.match_value("}") && !self.match_kind(TokenKind.EOF)) {
        l.add(self.parse_statement())
    }
    self.consume_value(TokenKind.Symbol, "}")
    return stmts
}

fn Parser.parse_if(): ptr {
    self.advance() // skip if
    let cond = self.parse_expression()
    let body = self.parse_block_node()
    let mut else_body = 0
    if (self.match_value("else")) {
        self.advance()
        if (self.match_value("if")) {
            else_body = self.parse_if()
        } else {
            else_body = self.parse_block_node()
        }
    }
    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.IfStatement
    n.data1 = cond
    n.data2 = body
    n.data3 = else_body
    return node
}

fn Parser.parse_while(): ptr {
    self.advance() // skip while
    let cond = self.parse_expression()
    let body = self.parse_block_node()
    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.WhileStatement
    n.data1 = cond
    n.data2 = body
    return node
}

fn Parser.parse_let(): ptr {
    self.advance() // let
    let mut is_mut = false
    if (self.match_value("mut")) {
        self.advance()
        is_mut = true
    }
    let name_tok: Token = self.consume(TokenKind.Ident)
    self.consume_value(TokenKind.Operator, "=")
    let expr = self.parse_expression()

    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.Let
    n.data1 = name_tok.value
    n.data2 = expr
    n.data3 = is_mut
    return node
}

fn Parser.parse_fn(): ptr {
    self.advance() // fn
    let name_tok: Token = self.consume(TokenKind.Ident)
    self.consume_value(TokenKind.Symbol, "(")
    // skip params for now
    while (!self.match_value(")") && !self.match_kind(TokenKind.EOF)) { self.advance() }
    self.consume_value(TokenKind.Symbol, ")")

    // return type?
    if (self.match_value(":") || self.match_value("->")) {
        self.advance()
        self.advance() // type name
    }

    let body = self.parse_block_node()
    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.Fn
    n.data1 = name_tok.value
    n.data2 = body
    return node
}

fn Parser.parse_for(): ptr {
    self.advance() // for
    self.consume_value(TokenKind.Symbol, "(")
    let init = self.parse_statement()
    self.consume_value(TokenKind.Symbol, ";")
    let cond = self.parse_expression()
    self.consume_value(TokenKind.Symbol, ";")
    let update = self.parse_statement()
    self.consume_value(TokenKind.Symbol, ")")
    let body = self.parse_block_node()

    let node = malloc(40)
    let n: Node = node
    n.kind = NodeType.For
    n.data1 = init
    n.data2 = cond
    n.data3 = update
    n.data4 = body
    return node
}
